package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"log"
	"net"
	"os"
	"strings"
	"sync"
	"time"
)

var ReportBucket =  map[string]time.Duration{}

var reportMutex sync.Mutex

func UpdateReport( testName string , t time.Duration ) {
	reportMutex.Lock()
	defer reportMutex.Unlock()
	k,ok := ReportBucket[testName]
	if ok {
		ReportBucket[testName]  = k + t
	} else {
		ReportBucket[testName] = t
	}
}

type Tests struct {
	Name   string `json:"name"`
	XmlResponseEndtag string `json:"xml_response_endtag"`
	XML    string `json:"xml"`
	Repeat int    `json:"repeat"`
	MeasureTime   bool `json:"measure_time"`
	RandomKeyName bool `json:"random_key_name"`
	Log bool `json:"log"`
}

type AutoGenerated struct {
	Parallel int `json:"parallel"`
	NAEIpPort   string `json:"nae_ip_port"`
	Tests   []Tests `json:"tests"`
}

func sendRequest( conn net.Conn , t Tests, buff []byte ) {

	total := 0
	for total < len(t.XML) {
		n,err := conn.Write([]byte(t.XML))
		if err != nil {
			panic(err)
		}
		total += n
	}
	out := bytes.Buffer{}
	for {
		size, err := conn.Read(buff)
		if err != nil {
			panic(fmt.Errorf("%v %v",err, t))
		}
		out.Write(buff[:size])
		if strings.Contains(string(buff[:size]), t.XmlResponseEndtag) {
			break
		}
	}

	if t.Log {
		log.Println(t , string(out.Bytes()))
	}

}

func preprocessXML( t Tests) string {
	kn := ""
	if t.RandomKeyName {
		kn = uuid.New().String()
		return fmt.Sprintf(t.XML , kn )
	}
	return t.XML
}


func execTests( ip string , naeTest []Tests, wg *sync.WaitGroup, id string) {

	defer wg.Done()

	conn,err := net.Dial("tcp", ip)

	if err != nil {
		panic(err)
	}

	in := make([]byte,4096)

	var m time.Time
	var out time.Duration

	for _,v := range naeTest {


		if v.MeasureTime {
			m = time.Now()
		}

		for v.Repeat > 0 {
			xml := v.XML
			v.XML = preprocessXML( v )
			sendRequest(conn, v, in)
			v.Repeat--
			v.XML = xml
		}
		if v.MeasureTime {
			out = time.Since(m)
			UpdateReport( v.Name+ "_" + id , out )
		}
	}
}

func main() {
	if len(os.Args) < 2 {
		panic("Minimum arguments requred are 2")
	}

	testf,err := os.Open(os.Args[1])
	if err != nil {
		panic(err)
	}

	d := json.NewDecoder(testf)

	t := &AutoGenerated{}

	err = d.Decode(t)
	if err != nil {
		panic(err)
	}

	w := sync.WaitGroup{}

	w.Add(t.Parallel)


	for i := 0 ;i < t.Parallel ; i++ {
		go execTests( t.NAEIpPort , t.Tests, &w, fmt.Sprintf("%d",i) )
	}

	w.Wait()

	for k,v := range ReportBucket {
		fmt.Println(k , v)
	}

}
